name: 🔒 Reusable Security Scan

on:
  workflow_call:
    inputs:
      scan-type:
        description: 'Type of security scan to run'
        required: true
        type: string
        default: 'full'
      fail-on-severity:
        description: 'Minimum severity level to fail the workflow'
        required: false
        default: 'high'
        type: string
      timeout-minutes:
        description: 'Timeout for the entire scan'
        required: false
        default: 30
        type: number
      include-dependencies:
        description: 'Include dependency scanning'
        required: false
        default: true
        type: boolean
      include-secrets:
        description: 'Include secrets scanning'
        required: false
        default: true
        type: boolean
      include-sast:
        description: 'Include SAST scanning'
        required: false
        default: true
        type: boolean
    secrets:
      NPM_TOKEN:
        required: false
      SUPABASE_ACCESS_TOKEN:
        required: false

permissions:
  contents: read
  security-events: write
  actions: read
  pull-requests: read

jobs:
  security-scan:
    name: 🔍 Security Scan (${{ inputs.scan-type }})
    runs-on: ubuntu-latest
    timeout-minutes: ${{ inputs.timeout-minutes }}
    concurrency:
      group: security-scan-${{ github.ref }}
      cancel-in-progress: false

    steps:
      - name: 🌐 Network Diagnostic
        run: |
          echo "🔍 Running network diagnostics..."
          echo "Testing connectivity to GitHub..."
          ping -c 3 github.com || echo "Ping failed, trying curl..."
          curl -I https://github.com || echo "HTTPS connection failed"
          nslookup github.com || echo "DNS lookup failed"
          echo "Network diagnostic completed"

      - name: 📦 Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: 🛡️ Setup Security Tools
        run: |
          echo "🔧 Setting up security scanning environment..."
          echo "Scan type: ${{ inputs.scan-type }}"
          echo "Fail on severity: ${{ inputs.fail-on-severity }}"
          echo "Timeout: ${{ inputs.timeout-minutes }} minutes"
          
          # Install gitleaks if secrets scanning is enabled
          if [[ "${{ inputs.include-secrets }}" == "true" ]]; then
            echo "📥 Installing gitleaks..."
            
            # Try multiple installation methods with better error handling
            if command -v wget >/dev/null 2>&1; then
              echo "Using wget to download gitleaks..."
              # Get the latest version from GitHub API
              LATEST_VERSION=$(wget -qO- https://api.github.com/repos/zricethezav/gitleaks/releases/latest | grep -o '"tag_name": "v[^"]*"' | cut -d'"' -f4)
              if [ -n "$LATEST_VERSION" ]; then
                echo "Latest gitleaks version: $LATEST_VERSION"
                wget -qO- "https://github.com/zricethezav/gitleaks/releases/download/${LATEST_VERSION}/gitleaks_${LATEST_VERSION}_linux_x64.tar.gz" | tar -xz -C /usr/local/bin gitleaks || echo "⚠️ wget installation failed"
              else
                echo "⚠️ Could not determine latest version, trying fallback..."
                wget -qO- https://github.com/zricethezav/gitleaks/releases/latest/download/gitleaks_linux_x64.tar.gz | tar -xz -C /usr/local/bin gitleaks || echo "⚠️ wget fallback failed"
              fi
            elif command -v curl >/dev/null 2>&1; then
              echo "Using curl to download gitleaks..."
              # Get the latest version from GitHub API
              LATEST_VERSION=$(curl -s https://api.github.com/repos/zricethezav/gitleaks/releases/latest | grep -o '"tag_name": "v[^"]*"' | cut -d'"' -f4)
              if [ -n "$LATEST_VERSION" ]; then
                echo "Latest gitleaks version: $LATEST_VERSION"
                curl -sL "https://github.com/zricethezav/gitleaks/releases/download/${LATEST_VERSION}/gitleaks_${LATEST_VERSION}_linux_x64.tar.gz" | tar -xz -C /usr/local/bin gitleaks || echo "⚠️ curl installation failed"
              else
                echo "⚠️ Could not determine latest version, trying fallback..."
                curl -sL https://github.com/zricethezav/gitleaks/releases/latest/download/gitleaks_linux_x64.tar.gz | tar -xz -C /usr/local/bin gitleaks || echo "⚠️ curl fallback failed"
              fi
            else
              echo "⚠️ Neither wget nor curl available, trying alternative method..."
              # Alternative: use apt if available
              if command -v apt-get >/dev/null 2>&1; then
                apt-get update -qq && apt-get install -y gitleaks || echo "⚠️ apt-get installation failed"
              else
                echo "⚠️ No suitable installation method found"
              fi
            fi
            
            # Verify installation
            if command -v gitleaks >/dev/null 2>&1; then
              echo "✅ Gitleaks installed successfully"
              gitleaks version
            else
              echo "⚠️ Gitleaks installation failed, will use basic pattern matching"
            fi
          fi

      - name: 🔐 Secrets Detection (gitleaks)
        if: ${{ inputs.include-secrets == 'true' }}
        run: |
          echo "🔍 Running secrets detection..."
          
          if command -v gitleaks >/dev/null 2>&1; then
            echo "Using gitleaks for secrets detection..."
            gitleaks detect \
              --source . \
              --report-format json \
              --report-path gitleaks-report.json \
              --exit-code 0 \
              --verbose
            
            # Check if any secrets were found
            if [ -s gitleaks-report.json ]; then
              echo "⚠️  Secrets detected! Review the report:"
              cat gitleaks-report.json | jq -r '.findings[] | "\(.rule) in \(.file):\(.startLine)"' || true
              if [[ "${{ inputs.fail-on-severity }}" == "low" ]]; then
                exit 1
              fi
            else
              echo "✅ No secrets detected"
            fi
          else
            echo "⚠️ Gitleaks not available, using basic pattern matching..."
            
            # Basic pattern matching for common secrets
            echo "🔍 Running basic pattern matching for secrets..."
            
            # Create a simple report
            cat > gitleaks-report.json << EOF
            {
              "findings": []
            }
            EOF
            
            # Search for common secret patterns
            if find . -type f \( -name "*.js" -o -name "*.ts" -o -name "*.json" -o -name "*.env*" \) -exec grep -l -E "(api_key|secret|password|token|private_key)" {} \; > potential-secrets.txt 2>/dev/null; then
              if [ -s potential-secrets.txt ]; then
                echo "⚠️ Potential secrets found in files:"
                cat potential-secrets.txt
                echo "⚠️ Basic pattern matching completed - review files manually"
              else
                echo "✅ No obvious secrets detected with basic pattern matching"
              fi
            else
              echo "✅ Basic pattern matching completed - no obvious secrets found"
            fi
          fi

      - name: 📦 Dependency Vulnerability Scan
        if: ${{ inputs.include-dependencies == 'true' }}
        run: |
          echo "📦 Scanning dependencies for vulnerabilities..."
          
          # Check for package files
          if [ -f "package.json" ]; then
            echo "📋 Found package.json, running npm audit..."
            npm audit --audit-level=${{ inputs.fail-on-severity }} --json > npm-audit.json || true
            
            # Parse and report findings
            if [ -s npm-audit.json ]; then
              echo "📊 NPM Audit Results:"
              jq -r '.vulnerabilities | to_entries[] | "\(.key): \(.value.severity) - \(.value.title)"' npm-audit.json || true
              
              # Count vulnerabilities by severity
              critical_count=$(jq -r '.vulnerabilities | to_entries[] | select(.value.severity == "critical") | .key' npm-audit.json | wc -l)
              high_count=$(jq -r '.vulnerabilities | to_entries[] | select(.value.severity == "high") | .key' npm-audit.json | wc -l)
              moderate_count=$(jq -r '.vulnerabilities | to_entries[] | select(.value.severity == "moderate") | .key' npm-audit.json | wc -l)
              low_count=$(jq -r '.vulnerabilities | to_entries[] | select(.value.severity == "low") | .key' npm-audit.json | wc -l)
              
              echo "📊 Vulnerability Summary:"
              echo "  Critical: $critical_count"
              echo "  High: $high_count"
              echo "  Moderate: $moderate_count"
              echo "  Low: $low_count"
            else
              echo "✅ No vulnerabilities found in npm audit"
            fi
          fi
          
          if [ -f "bun.lockb" ]; then
            echo "📋 Found bun.lockb, running bun audit..."
            bun audit --json > bun-audit.json || true
          fi
          
          # Check for other package managers
          if [ -f "yarn.lock" ]; then
            echo "📋 Found yarn.lock, running yarn audit..."
            yarn audit --level ${{ inputs.fail-on-severity }} --json > yarn-audit.json || true
          fi
          
          if [ -f "pnpm-lock.yaml" ]; then
            echo "📋 Found pnpm-lock.yaml, running pnpm audit..."
            pnpm audit --audit-level ${{ inputs.fail-on-severity }} --json > pnpm-audit.json || true
          fi

      - name: 🔍 SAST Analysis (CodeQL)
        if: ${{ inputs.include-sast == 'true' }}
        uses: github/codeql-action/init@v3
        with:
          languages: javascript
          queries: +security-and-quality

      - name: 🔍 Perform SAST Analysis
        if: ${{ inputs.include-sast == 'true' }}
        uses: github/codeql-action/analyze@v3
        with:
          category: "/language:javascript"

      - name: 📊 Generate Security Report
        run: |
          echo "📊 Generating comprehensive security report..."
          
          # Calculate scan duration
          scan_duration=$(($SECONDS / 60))
          
          # Create summary report
          cat << EOF > security-report.md
          # Security Scan Report
          
          **Scan Type:** ${{ inputs.scan-type }}
          **Timestamp:** $(date -Is)
          **Repository:** ${{ github.repository }}
          **Branch:** ${{ github.ref_name }}
          **Commit:** ${{ github.sha }}
          **Duration:** ${scan_duration} minutes
          **Fail Threshold:** ${{ inputs.fail-on-severity }}
          
          ## Scan Configuration
          
          - **Dependency Scanning:** ${{ inputs.include-dependencies }}
          - **Secrets Detection:** ${{ inputs.include-secrets }}
          - **SAST Analysis:** ${{ inputs.include-sast }}
          - **Timeout:** ${{ inputs.timeout-minutes }} minutes
          
          ## Scan Summary
          
          - ✅ Repository checkout completed
          - ✅ Security tools configured
          - $([ "${{ inputs.include-secrets }}" == "true" ] && echo "✅ Secrets detection completed" || echo "⏭️ Secrets detection skipped")
          - $([ "${{ inputs.include-dependencies }}" == "true" ] && echo "✅ Dependency scan completed" || echo "⏭️ Dependency scan skipped")
          - $([ "${{ inputs.include-sast }}" == "true" ] && echo "✅ SAST analysis completed" || echo "⏭️ SAST analysis skipped")
          
          ## Security Posture
          
          Based on the scan results, your security posture is:
          $(if [ -s gitleaks-report.json ]; then echo "⚠️ **Needs Attention** - Secrets detected"; else echo "✅ **Good** - No secrets detected"; fi)
          $(if [ -s npm-audit.json ]; then echo "⚠️ **Needs Attention** - Dependencies have vulnerabilities"; else echo "✅ **Good** - Dependencies are secure"; fi)
          
          ## Recommendations
          
          1. **Immediate Actions:**
             - Review any high/critical severity findings
             - Address detected secrets immediately
             - Update vulnerable dependencies
          
          2. **Long-term Improvements:**
             - Implement automated blocking for critical findings
             - Set up regular security scans
             - Establish security review processes
          
          3. **Best Practices:**
             - Use environment variables for secrets
             - Keep dependencies updated
             - Implement code review for security
          
          ## Next Steps
          
          1. Review any findings in the logs above
          2. Address high/critical severity issues
          3. Consider implementing automated blocking for critical findings
          4. Schedule follow-up security reviews
          
          ---
          
          *Report generated by Autonomous Security Scan System*
          
          EOF
          
          echo "📄 Security report generated: security-report.md"

      - name: 🚨 Security Check Summary
        run: |
          echo "🔒 Security scan completed successfully!"
          echo "📋 Scan type: ${{ inputs.scan-type }}"
          echo "🎯 Fail threshold: ${{ inputs.fail-on-severity }}"
          echo "⏱️ Duration: $(($SECONDS / 60)) minutes"
          
          # Check for any critical findings that should fail the build
          if [[ "${{ inputs.fail-on-severity }}" == "critical" ]] && [ -s gitleaks-report.json ]; then
            echo "🚨 Critical secrets detected - failing build"
            exit 1
          fi
          
          echo "✅ All security checks passed within configured thresholds"
